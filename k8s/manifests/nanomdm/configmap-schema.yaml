apiVersion: v1
kind: ConfigMap
metadata:
  name: nanomdm-schema
  namespace: nanomdm
data:
  schema.sql: |-
    CREATE TABLE IF NOT EXISTS devices (
        id TEXT NOT NULL,
        identity_cert BYTEA NULL,
        serial_number TEXT NULL,
        unlock_token BYTEA NULL,
        authenticate BYTEA NOT NULL,
        authenticate_at TIMESTAMP DEFAULT NOW(),
        token_update BYTEA NULL,
        token_update_at TIMESTAMP NULL,
        bootstrap_token_b64 TEXT NULL,
        bootstrap_token_at TIMESTAMP NULL,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        PRIMARY KEY (id)
    );

    CREATE TABLE IF NOT EXISTS users (
        id TEXT NOT NULL,
        device_id TEXT NOT NULL REFERENCES devices (id),
        user_short_name TEXT NULL,
        user_long_name TEXT NULL,
        token_update BYTEA NULL,
        token_update_at TIMESTAMP NULL,
        user_authenticate BYTEA NULL,
        user_authenticate_at TIMESTAMP NULL,
        user_authenticate_digest BYTEA NULL,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        PRIMARY KEY (id, device_id)
    );

    CREATE TABLE IF NOT EXISTS enrollments (
        id TEXT NOT NULL,
        device_id TEXT NOT NULL REFERENCES devices (id),
        user_id TEXT NULL,
        type TEXT NOT NULL DEFAULT '',
        topic TEXT NULL,
        push_magic TEXT NULL,
        token_hex TEXT NULL,
        enabled BOOLEAN NOT NULL DEFAULT TRUE,
        token_update_tally INTEGER NOT NULL DEFAULT 1,
        last_seen_at TIMESTAMP DEFAULT NOW(),
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        PRIMARY KEY (id),
        FOREIGN KEY (user_id, device_id) REFERENCES users (id, device_id)
    );

    CREATE TABLE IF NOT EXISTS commands (
        command_uuid TEXT NOT NULL,
        request_type TEXT NOT NULL DEFAULT '',
        command BYTEA NOT NULL,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        PRIMARY KEY (command_uuid)
    );

    CREATE TABLE IF NOT EXISTS command_results (
        id TEXT NOT NULL,
        command_uuid TEXT NOT NULL REFERENCES commands (command_uuid),
        status TEXT NOT NULL DEFAULT '',
        result BYTEA NULL,
        not_now_at TIMESTAMP NULL,
        not_now_tally INTEGER NOT NULL DEFAULT 0,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        PRIMARY KEY (id, command_uuid)
    );

    CREATE TABLE IF NOT EXISTS enrollment_queue (
        id TEXT NOT NULL REFERENCES enrollments (id),
        command_uuid TEXT NOT NULL REFERENCES commands (command_uuid),
        active BOOLEAN NOT NULL DEFAULT TRUE,
        priority INTEGER NOT NULL DEFAULT 0,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        PRIMARY KEY (id, command_uuid)
    );

    CREATE TABLE IF NOT EXISTS push_certs (
        topic TEXT NOT NULL,
        cert_pem BYTEA NOT NULL,
        key_pem BYTEA NOT NULL,
        stale_token INTEGER NOT NULL DEFAULT 0,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        PRIMARY KEY (topic)
    );

    CREATE TABLE IF NOT EXISTS cert_auth_associations (
        id TEXT NOT NULL,
        sha256 TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        PRIMARY KEY (id, sha256)
    );

    CREATE OR REPLACE VIEW view_queue AS
        SELECT
            q.id,
            q.created_at AS queue_created_at,
            q.active,
            q.priority,
            c.command_uuid,
            c.request_type,
            c.command,
            r.updated_at AS result_updated_at,
            r.status,
            r.result
        FROM
            enrollment_queue AS q
            INNER JOIN commands AS c
                ON q.command_uuid = c.command_uuid
            LEFT JOIN command_results r
                ON r.command_uuid = q.command_uuid AND r.id = q.id
        ORDER BY
            q.priority DESC,
            q.created_at;
